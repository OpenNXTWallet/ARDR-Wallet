package nxt.addons;

import nxt.account.Account;
import nxt.blockchain.Chain;
import nxt.blockchain.ChildChain;
import nxt.crypto.Crypto;
import nxt.util.Convert;
import nxt.util.Logger;

import java.util.HashMap;
import java.util.Map;

public class ContractRunnerConfig {

    private static final String ERROR_PREFIX = "contract runner config error: ";

    private final String secretPhrase;
    private final byte[] publicKey;
    private final String publicKeyHexString;
    private final long accountId;
    private final String account;
    private final String accountRs;
    private final Map<Integer, Long> feeRatePerChain;
    private final JO params;
    private final boolean isValidator;
    private final int catchUpInterval;
    private final ContractProvider contractProvider;
    private final byte[] runnerSeed;

    ContractRunnerConfig(JO config, ContractProvider contractProvider) {
        secretPhrase = config.getString("secretPhrase");
        if (secretPhrase == null) {
            String accountRS = config.getString("accountRS");
            if (accountRS == null) {
                throw new IllegalArgumentException(ERROR_PREFIX + "secretPhrase or accountRS must be defined");
            }
            accountId = Convert.parseAccountId(accountRS);
            publicKey = Account.getPublicKey(accountId);
            if (publicKey == null) {
                throw new IllegalArgumentException(String.format(ERROR_PREFIX + "account %s does not have a public key", accountRS));
            }
        } else {
            accountId = Account.getId(Crypto.getPublicKey(secretPhrase));
            publicKey = Crypto.getPublicKey(secretPhrase);
        }
        publicKeyHexString = Convert.toHexString(publicKey);
        account = Long.toUnsignedString(accountId);
        accountRs = Convert.rsAccount(accountId);
        feeRatePerChain = new HashMap<>();
        for (Chain chain : ChildChain.getAll()) {
            String setting = "feeRateNQTPerFXT." + chain.getName();
            if (config.isExist(setting)) {
                feeRatePerChain.put(chain.getId(), config.getLong(setting));
            }
        }
        if (secretPhrase != null && feeRatePerChain.size() == 0) {
            throw new IllegalArgumentException(ERROR_PREFIX + "feeRateNQTPerFXT not specified for any chain");
        }
        if (config.isExist("params")) {
            params = config.getJo("params");
        } else {
            params = new JO();
        }
        isValidator = config.getBoolean("validator", false);
        catchUpInterval = config.getInt("catchUpInterval", 3600);
        if (config.isExist("seed")) {
            runnerSeed = config.parseHexString("seed");
            if (runnerSeed.length < 16) {
                Logger.logWarningMessage("Contract runner random seed is shorter than 16 bytes, it might be possible to brute force it");
            }
        } else {
            Logger.logWarningMessage("Contract runner random seed not specified, random values generated by this contract runner will be predictable");
            runnerSeed = publicKey;
        }
        this.contractProvider = contractProvider;
    }

    public String getSecretPhrase() {
        return secretPhrase;
    }

    public byte[] getPublicKey() {
        return publicKey;
    }

    public String getPublicKeyHexString() {
        return publicKeyHexString;
    }

    public long getAccountId() {
        return accountId;
    }

    public String getAccount() {
        return account;
    }

    public String getAccountRs() {
        return accountRs;
    }

    public long getFeeRateNQTPerFXT(int chainId) {
        if (feeRatePerChain.get(chainId) == null) {
            return -1;
        }
        return feeRatePerChain.get(chainId);
    }

    public JO getParams() {
        return params;
    }

    public boolean isValidator() {
        return isValidator;
    }

    public int getCatchUpInterval() {
        return catchUpInterval;
    }

    public byte[] getRunnerSeed() {
        return runnerSeed;
    }

    public ContractProvider getContractProvider() {
        return contractProvider;
    }
}
